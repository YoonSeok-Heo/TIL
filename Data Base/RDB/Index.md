# 인덱스(Index)

## 인덱스란?
인덱스는 데이터베이스 테이블에 대한 검색 성능을 높여주는 구조이다.


특정 컬럼에 인덱스를 생성하면 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다.
<br>인덱스가 생성된 후 쿼리문에서 인덱스가 걸려있는 컬럼에 WHERE조건을 거는 등의 작업을 하면 [\*옵티마이저](https://github.com/YoonSeok-Heo/TIL/blob/main/Data%20Base/RDB/MySql.md#%EC%98%B5%ED%8B%B0%EB%A7%88%EC%9D%B4%EC%A0%80)에서 판단하여 생성된 인덱스를 타게 된다.
<br>검색 순서로는 가장먼저 인덱스를 타게되고 인덱스에 저장되어 있는 데이터의 물리적 주소로 접근해 데이터를 가져오는 식으로 동작한다.


또한 인덱스 생성 시 데이터를 **오름차순으로 정렬**하기 때문에 정렬된 주소체계라고 표현할 수 있다.

![image](https://user-images.githubusercontent.com/113662725/214075589-d6e73216-5ca9-4127-ab12-855d99170dd5.png)

---

## 인덱스를 사용하는 이유(장점)
인덱스의 가장 큰 특징은 데이터들이 정렬 되어 있다는 점이다. 이 특징으로 인해 조건 검색이라는 영역에서 굉장한 장점이 된다.

### 1. 조건 검색 WHERE절의 효율성
테이블을 만들고 데이터가 쌓이게 되면서 내부적으로 레코드의 순서 섞이게 된다. 정렬이 되어있지 않는 레코드에서 검색을 할 경우 모든 레코드의 값을 비교해야한다.
하지만 인덱스 테이블을 스캔할 경우 값이 정렬되어 저장되어 있기때문에 데이터를 빠르게 찾아낼 수 있다.

### 2. 정렬 Order by절의 효율성
Order by는 부하가 많이 걸리는 작업이다. 인덱스를 사용하면 Order by에 의한 정렬(Sort) 과정을 피할 수가 있다.
<br>1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하면 **\*디스크I/O**도 추가적으로 발생하게 된다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 된다. 
<br>**※ 이미 정렬되어 있기 때문이다.!**

\*디스크I/O: 데이터를 작성 변경할 때 디스크를 사용하게 되는데, 컴퓨터의 구조를 공부하다보면 컴퓨터에서 가장 느린 부분 중 하나가 디스크이다. 메모리와 디스크의 속도차이는 어마무시하다.


### 3. Min, Max의 효율적인 처리가 가능하다.
Min, Max의 값은 인덱스의 시작 값 또는 끝 값 한개씩 가져오기 때문에 효율적으로 처리가 가능하다.

---
## 인덱스를 사용하면 무조건 효율이 좋을까?(단점)
인덱스의 가장 큰 문제점은 정렬된 상태를 계속 유지시켜 줘야 한다는 점이다. 레코드 내에 데이터 값이 자주 바뀐다면 악영향을 미친다.

### 1. 인덱스는 DML에 취약
INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀐다면 인덱스 테이블 내에 있는 값들을 재정렬 해야한다.
<br>그리고 위 이미지에서 보듯이 인덱스 테이블과 원본 테이블 두 군데의 테이터 수정 작업을 해줘야 한다는 단점도 발생한다.
<br>그렇기 때문에 DML이 빈번한 테이블보다 검색을 위주로 하는 테이블에 인덱스를 생성하는 것이 좋다.

### 2. 무조건 인덱스 스캔이 좋은 것은 아니다.
검색 위주의 테이블은 인덱스를 생성하는 것이 좋지만 무조건 검색 시에도 인덱스가 좋은 것은 아니다. **인덱스는 테이블의 전체 데이터 중에서 10 ~ 15%의 데이터를 처리하는 경우에만 효율적이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 좋다.** 직관적인 예시를 들자면 1개의 데이터가 있는 테이블과 100만 개의 데이터가 있는 테이블이 있다면, 1개의 데이터가 있는 테이블은 굳이 인덱스 스캔보다는 풀 스캔이 빠를 것이다.

### 3. 속도 향상을 위해 인덱스를 많이 만드는 것은 좋지 않다. 
인덱스를 관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요하다. 무턱대고 인덱스를 만들어서는 결코 안 된다는 것이다. 즉, 속도 향상에 비해 단점들의 비용을 비교해 인덱스를 만들지 말지 결정해야한다.

---
## 인덱스를 남발하지 말아야 하는 이유!
- 데이터베이스 서버에 성능 문제가 발생하면 **가장 빨리 생각하는 해결책이 인덱스 추가 생성**이다. 문제가 발생할 때마다 인덱스를 생성하면서 **인덱스가 쌓여가는 것은 하나의 쿼리문을 빠르게**는 만들 수 있지만, **전체적인 데이터베이스의 성능 부하**를 초래한다.

- 조회 성능을 극대화하려 만든 객체인데 많은 인덱스가 쌓여서 INSERT, UPDATE, DELETE 시에 부하가 발생해 전체적인 데이터베이스 성능을 저하한다.

- 그렇기에 **인덱스를 생성하는 것보다는 SQL문을 좀 더 효율적으로 짜는 방향**으로 나가야 한다. 인덱스 생성은 **마지막 수단**으로 강구해야 할 문제이다.

---
## 인덱스의 관리

인덱스는 항상 최신의 데이터를 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다.
<br>그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 계속 정렬을 해주어야 하고 그에 따른 부하가 발생한다.
- INSERT: 새로운 데이터에 대한 인덱스를 추가한다.
- UPDATE: 기존의 인덱스를 사용하지 않는 상태로 변경하고, 갱신된 데이터에 대해 인덱스를 추가한다.
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는 상태로 변경한다.

---
## 인덱스 생성 전략
생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한으로 그리고 조건절에 호출 빈도는 자주 사용되는 컬럼을 인덱스로 생성하는 것이 좋다.
<br>인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 인덱스 테이블이 생성된다.
<br>이 기준 컬럼은 최대한 중복이 되지 않는 값이 좋다. **※ 최선의 방법은 PK로 인덱스를 거는 것**
<br>중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키고, 반대로 모든 값이 같은 컬럼의 인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야한다.

1. 조건절에 자주 등장하는 컬럼
2. 항상 = 으로 비교되는 컬럼
3. 중복되는 데이터가 최소한인 컬럼(분포도가 좋은 컬럼)
4. order by절에서 자주 사용되는 컬럼
5. join조건으로 자주 사용되는 컬럼


---


