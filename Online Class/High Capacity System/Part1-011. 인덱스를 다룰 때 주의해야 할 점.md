# 인덱스를 다룰 때 주의해야 할 점

1. 인덱스 필드 가공
2. 복합 인덱스
3. 하나의 쿼리에는 하나의 인덱스만

## 1. 인덱스 필드 가공

```sql
// age는 int타입
SELECT * 
FROM Member
WHERE age * 10 = '1'
```
- 위 쿼리와 같이 age필드에 곱하기 10을 함으로써 인덱스를 탈 수가 없다.
- 또한 타입을 잘못넣어주게 된다면 인덱스를 타지 않는다.
  - age가 int타입일 경우 문자열로 넘길때 인덱스르 타지 않는다.
  - b tree에 저장되어 있는 타입은 int인데 실제로 들어오게 되는 값은 string이므로 옵티마이저가 age에 toString쿼리(가공)를 넣게된다.

## 2. 복합 인덱스

![image](https://user-images.githubusercontent.com/113662725/220152155-eebb3951-d458-4dad-9850-a030c7f31dba.png)

- 기존 과일에만있던 인덱스를 과일과 원산지에 인덱스를 넣어주게 된다면 과일순으로 정렬을하게 되고 과일이 같다면 원산지 순으로 정렬하게 된다.
- 여기서 WHERE문에 원산지가 들어오게 된다면 인덱스를 탈 수 없게 된다.
- **복합인덱스에서 선두에 들어오는 선두컬럼을 정해주는것이 중요하다.**

## 3. 하나의 쿼리에는 하나의 인덱스만
- 하나의 쿼리에는 하나의 인덱스만 탄다.
  - WHERE문에 여러개의 조건이 모드 개별 인덱스를 가지고 있을경우 옵티마이저에서는 한개의 조건만 인덱스를 태운다.
- 여러 인덱스 테이블을 동시에 탐색하지 않는다.


**※ index merge hint를 사용하면 여러개의 인덱스를 타는것도 가능**

## 마무리
- WHERE, ORDER BY, GROUP BY를 혼합해서 사용할 때에는 인덱스를 잘 고려해야함
  - ex) WHERE에서 인덱스를 탓지만 ORDER BY에서 인덱스를 타지 못하면 가지고온 데이터를 모두 정렬해야하는 상황이 발생한다.
- 의도대로 인덱스가 동작하지 않을 수 있음. explain으로 확인
- 인덱스도 비용이다. 쓰기를 희생하고 조회를 얻는 것
- 꼭 인덱스로만 해결할 수 있는 문제인가?
- 데이터의 식별 정도가 높은 값을 이용한다.
  - ex) 성별 남자와 여자 두개만 있으므로 인덱스가 효율적으로 이용되지 않는다.
