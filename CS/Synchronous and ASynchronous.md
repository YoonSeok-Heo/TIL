# Synchronous(동기) and Asynchronous(비동기)

동기 프로그래밍 비동기 프로그래밍 업무를 하다보면 자주 듣는 말이다.

알아보기로 하쟈.

[https://luv-n-interest.tistory.com/1121](https://luv-n-interest.tistory.com/1121)를 참고했다.

---

# Syschronous(동기)

**동기 작업**은 한 번에 한 개의 작업이 수행되는 것을 의미한다. 

즉, 먼저 실행한 작업이 끝나기 전까지는 **진행중인 작업 외의 다른 작업을 수행하지 못한다**는 것을 말한다.

> ※ HTTP 요청은 요청을 하면 무조건 응답을 받는다. 이것이 동기적이라고 말할 수 있다.


![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/7e6c3e05-e8f2-4001-ad87-27bfbe397f9c)

- 모든 I/O 요청-응답 작업의 일련의 순서를 따른다. **즉, 작업의 순서가 보장**된다.
- **작업 완료를 user space에서 판단**하고, **다음 작업을 언제 요청할지 결정**한다.
- 일련의 Pipeline을 준수하는 구조에서 효율적이다.

> - 현재 작업외의 다른작업을 하지 못한다는 말은 **작업의 순서가 보장**된다는 뜻이다.
> - 작업의 순서가 보장된다는 말은 '현재 작업의 응답'을 받는 시점과 '다음 작업을 요청'하는 시점을 맞추는 일이다.
> - 다음 작업이 있다는 것 자체가 순서가 있다는 것을 의미한다.
> - 선행 작업이 완료되기 전까지 다음 작업이 수행되지 않는다.

---

# Asyschronous(동기)

비동기 작업이란 한 번에 여러개의 작업이 수행될 수 있음을 의미한다.

즉, 현재 작업을 진행중이더라도 다른 작업을 동시에 수행 할 수 있다.

또한 작업에 대한 결과를 바로 원하지 않는다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/e69661c2-3f16-492b-8701-afa5bcd0fd60)

- kernel에 I/O 작업을 요청해두고 다른 작업 처리가 가능하나 작업의 순서는 보장되지 않는다.
- 작업 완료를 kernel space에서 통보해준다.
- 각 작업들이 독립적인거나, 작업 별 지연이 큰 경우 효율적이다.

> ※만약 다중 요청에 대한 처리와 동시성 처리를 잘할 수 있다면 비동기 작업의 속도가 더 빠를 것이다.


![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/4f28b986-f319-401f-9f95-2b7484c2ad44)

- 순서대로 처리하는 것보다. 동시에 여러개 실행되는 측면이 시간적으로 빠르게 작업이 끝이난다.
- 3개를 모두 한꺼번에 처리하지 않은 이유는 동기적으로 처리해야 하는 작업이 있고 비동기 적으로 착업해야하는 경우가 있다.

---

## 결론 

이미 동기 작업에는 익숙해져 있지만 더 빠른 작업을 위해서는 비동기 환경도 잘 다룰 수 있어야한다.

하지만, 서로 의존성이 있는 곳에서 작업한다면 비동기는 오히려 오류를 불러올 가능성이 높다.

> 비동기 프로그래밍은 independent task에 대해서 수행하는 것이 좋다
> 
> 각자 독립적인 작업을 수행했을 때 좋은 결과를 얻을 수 있을 것이다.(물론 해결방법은 있다.)


---

# 스레드에서의 동기 비동기

프로그램에서 I/O작업을 할 때 오버헤드가 큰 경우가 많다.

이런 경우 동기로 처리한다면 I/O를 마치기 전까지 해당 프로그램은 멈출 것이다.(blocking)

그럴 때 비동기를 활용해서 프로그램이 돌아가도록 하는 것이 좋다.

> Blocking 시간에 다른 작업을 한다는 뜻이다.


반대로 비동기 때문에 이전에 작업한 것들이 끝나지 않은 상태로 많은 연산을 요구하는 작업을 한다거나, 

의존성이 있는 작업을 한다면 그것 또한 문제가 되니 상황에 맞는 선택을 해야 할 것이다.

---

## 싱글 스레드의 동기 비동기

다음 그림은 싱글 스레드에서의 동기 작업이다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/580db18d-d170-4c12-a6e6-9bb0b559798b)

> 멀티 스레드도 동기 작업이 가능하다
> 
> ![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/990ccef3-d507-4abd-8175-bdc65152acd1)
> 
> 멀티 프로세서 시스템의 OS가 각 스레드를 제어해 동시에 task를 수행한다.
> 
> ※ 하지만 특정 프로그램은 멀티 스레드가 아니라 멀티 프로세스를 사용해 병렬수행하는 경우가 있다.(위와 같은 형식으로 수행)

---

싱글 스레드에서의 비동기 작업이다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/c9770ed8-6bdb-4f77-b62a-36d27a2d1377)

작업들이 interleaved 되어 있다.

복잡해 보이기도 하지만 프로그래머 입장에선 이것이 더 간단해 보인다. 

그 이유는 해당 시간에 따라 어떤 작업이 진행되고 있는지 쉽게 알 수 있기 때문이다.

> 다시 말해서 위와 같은 비동기 모델에서는 
> 
> 현재하고 있는 작업을 다른 작업에 대한 제어 권한을 명시적으로 양도할 떄까지 계속 수행한다.
> 
> 즉, Blocking 시간에 수행할 작업을 **명시적으로 정해주어야 한다**는 말이다.

 ---

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/60003f00-bc70-4427-895f-a9ccdc923fda)

위 이미지는 동기작업에서 blocking 영역도 그려놓았다.

> Blocking영역이란 해당 Thread가 사용되지 않고 있다고 생각해도 된다.

중간 회색 구역이 Blocking을 하는 것인데. 대부분의 Blocking은 해당 작업에서 I/O 또는 Memory R/W에 대한 작업이 대부분이다.
(CPU의 작업속도에 비해 많은 속도차이가 나서 생기는 구간이다.)


### 다시 위의 그림을 비교해 보자

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/f46f794e-f08b-462a-b3f7-847c286bc99d)

Blocking이 걸린 구간이 아래쪽 그림과 관련이 있어보인다. 

Blocking이 걸린 시간을 이용하여 다른 Task의 작업을 수행하고 있는 것이다. 


## 비동기 작업의 목적

동기적 작업에서 생기는 Blocking(wating)영역도 효율적으로 사용하고자 하는 것이다.

유일하게 비동기 작업이 Blocking되는 경우는 더 이상 수행할 것이 없을 때이다.

