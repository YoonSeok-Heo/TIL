# HTTP 개요

### [https://developer.mozilla.org/ko/docs/Web/HTTP/Overview](https://developer.mozilla.org/ko/docs/Web/HTTP/Overview)

**HTTP는 HTML문서와 같은 리소스를 가져울 수 있도록 해주는 프로토콜이다.**
HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초이며, 클라이언트-서버 프로토콜이기도 하다.

클라이언트-서버 프로토콜이란 수신자 측에 의해 요청이 초기화되는 프로토콜을 의미한다.

하나의 완전한 문서(웹 페이지)는 텍스트, 이미지, 비디오 등의 불러온(feched) 하위 문서로 재구성 된다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/d639775b-70bb-4d73-ae9d-839501a3e8f5)

클라이언트와 서버들은 개별적인 메시지 교환에 의해 통신한다(데이터 스트림과 대조적으로). 보통 브라우저인 클라이언트에서 전송하는 메시지 요청(requests)이라고 하며, 그에 대한 서버에서 전송하는 데이터를 메시지 응답(responses)이라고 부른다.

> 문서에서 데이터 스트림과 대조적이란 말이 있는데 데이터 스트림은 연결지향통신이지만 HTTP는 비연결성이라는 특징을 말한 것 같다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/4c9e0df7-7475-4ee3-b87b-05e3b8d645eb)

HTTP는 **애플리케이션 계층의 프로토콜**로, 신뢰 가능한 전송 프로토콜이라면 이론상으로는 무엇이든 사용할 수 있으나 **TCP 혹은 암호화된 TCP 연결인 TLS를 통해 전송**됩니다.

> HTTP/3에서는 TCP,TLS를통하지 않고 QUIC를 사용한다. QUIC는 UDP상에 구현된 프로토콜이다. 이 부분은 좀더 공부해봐야한다.

HTTP의 확장성 덕분에, 오늘날 하이퍼텍스트 문서 뿐만 아니라 이미지 비디오 HTML 폼 결과와 같은 내용을 서버로 포스트(POST)하기 위해서 사용하기도 한다.

---

## HTTP기반 시스템의 구성요소

요청은 하나의 개체, 사용자 에이전트(또는 그것을 대신하는 프록시)에 의해 전송됩니다. 
대부분의 경우, 사용자 에이전트는 브라우저지만, 무엇이든 될 수 있습니다. 
예를 들어, 검색 엔진 인덱스를 채워넣고 유지하기 위해 웹을 돌아다니는 로봇이 그러한 경우입니다.

> 마지막 문장의 로봇은 검색엔진에서 웹크롤링을 하기 위한 로봇으로 생각된다.

개별적인 요청들은 서버로 보내지며, 서버는 요청을 처리하고 response라고 불리는 응답을 제공한다.
이 요청과 응답 사이에는 어러 개체들이 있다.
예를 들면 다양한 작업을 수행하는 게이트웨이 또는 캐시 역할을 하는 프록시 등이 있다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/5b46ca36-8a51-4d6f-9a2e-d38a7be04c13)

실제로는 브라우저와 서버사이에는 좀 더 많은 컴퓨터들이 존제한다.: 라우터, 모뎀 등

웨의 계층적 설계 덕분에, 이들은 네트워크와 전성 계층내로 숨겨지고 HTTP는 애플리케이션 계층에 있다. 
네트워크 문제를 진단하는 것도 중요하지만, 기본 레이어들은 HTTP 명세와는 거의 관련이 없다.

--- 

## 클라이언트: 사용자 에이전트

**사용자 에이전트는 사용자를 대신하여 동작하는 모든 도구이다.**

이 역할은 주로 브라우저에 의해 수행되며, 엔지니어들과 자신들의 애플리케이션을 디버그하는 웹 개발자들이 사용하는 프로그램은 예외이다.

> 디버그하는 웹 개발자들이 사용하는 프로그램이라는건 PostMan같은걸 의미하나보다.

브라우저는 **항상** 요청을 보내는 개체이다. 브라우저는 결코 서버가 될 수 없다.

웹페이지를 표시하기 위해, 브라우저는 페이지의 HTML문서를 가져오기 위한 요청을 전송한 뒤, 
파일을 구문 분석하여 실행해야 할 스크립트 그리고 페이지 내 포함된 하위 리소스들(이미지나 비디오 등)을 잘 표시하기 위한 레이아웃 정보(CSS)에 대응하는 추가적인 요청들을 가져온다.
그런 뒤에 브라우저는 완전한 문서인 웹 페이지를 표시하기 위해 받아온 리소스들을 혼합하고 그에 따라 웹페이지를 갱신하게 된다.

---

## 웹 서버

클라이언트에 의한 요청에 대한 문서를 제공하는 서버가 존재한다.
서버는 사실 상 논리적으로 단일 기계이다. 이는 로드벨런싱 혹은 그때 그때 다른 컴퓨터(캐시, DB 서버 등과 같은)들의 정보를 얻고 완전하게 혹은 부분적으로 문서를 생성하는 소프트웨어의 복잡한 부분을 공유하는 서버들의 집합 일 수 있기 때문이다.

서버는 반드시 단일 머신일 필요는 없지만, 여러 개의 서버를 동일한 머신 위에서 호스팅 할 수는 있다.

---

## 프록시

웹 브라우저와 서버 사이에서는 수많은 컴퓨터와 머신이 HTTP 메시지를 이어 받고 전달한다.
여러 계층으로 이루어진 웹 스택 구조에서는 이러한 컴퓨터/머신들은 대부분 전송, 네트워크 혹은 물리계층에서 동작하며,
성능에 상당히 큰 영향을 주지만 HTTP계층에서는 이들이 어떻게 동작하는지 눈에 보이지 않는다.
이러한 컴퓨터/머신 중에서도 애플리케이션 계층에서 동작하는 것들을 일반적으로 **프록시**라고 부른다
프록시는 눈에 보이거나 그렇지 않을 수도 있으며(프록시를 통해 요청이 변경되거나 변경되지 않는 경우를 말함) 다양한 기능들을 수행할 수 있다.

- 캐싱: 캐시는 공개 또는 비공개가 될 수 있다.(예: 브라우저 캐시)
- 필터링: 바이러스 백신 스캔, 유해 컨텐츠 차단 기능
- 로드 밸런싱: 여러 서버들이 서로 다른 요청을 처리하도록 허용
- 인증: 다양한 리소스에 대한 접근 제어
- 로깅: 이력 정보 저장

---

## HTTP의 기초적인 측면

### HTTP는 간단합니다.

HTTP는 사람이 읽을 수 있으며, 간단하게 고안되었다. 
심지어 HTTP/2가 다서 더 복자해졌지만 여전히 HTTP 메시지를 프레임별로 캡슐화하여 간결함을 유지하였다.
HTTP 메시지들은 사람이 읽고 이해할 수 있어, 테스트가 쉽고 초심자의 진입장볍을 낮췄다.

### HTTP는 확장 가능하다.

HTTP/1.0에서 소개된, HTTP 헤더는 HTTP를 확장하고 실험이 쉽게 만들어졌다.
클라이언트와 서버가 새로운 헤더의 시맨틱에 대해 간단한 합의만 한다면, 
언제든지 새로운 기능을 추가할 수 있습니다.

### HTTP는 상태는 없지만 세션은 있다.

HTTP는 상태를 저장하지 않는다(Stateless).
동일한 연결 상에서 연속하여 전달된 두 개의 요청은 아무 연결 고리가 없다.
이는 쇼핑 장바구니처럼 **일관된 방식으로 사용자가 페이지와의 상호작용을 원할 때 문제가된다.**
하지만 HTTP의 쿠키는 상태가 있는 세션을 만들도록 해준다. 
헤더 확장성을 사용하여, 동일한 컨텍스트 또는 동일한 상태를 공유하기 위해 각각의 요청들에 세션을 만들도록 HTTP 쿠키가 추가된다.

> 일관된 방식으로 사용자가 페이지와의 사용작용을 원할 때 문제가 된다고 했는데,
> 
> 예를들어 상태를 저장하지 않는다면, 
> 장바구니에 담은 품목이 다른 페이지로 넘어가면서 상태저장이 안되고 장바구니에 넣은 품목들이 사라진다는 것이다.
> 하지만 쿠키를 이용해 브라우저와 서버와 세션을 만들게 된다면,
> 우리가 사용하는 장바구니처럼 다른 페이지로 넘어가도 장바구니에 추가한 상품이 없어지지 않는다.


---

### HTTP와 연결

연결은 전송 계층에서 제어되므로 HTTP의 영역 밖이다.(HTTP는 위에서도 나왔듯이 애플리케이션 계층이다.)
HTTP는 연결될 수 있도록 하는 근본적인 전송 프로토콜을 요구하지 않는다.
다만 그저 신뢰할 수 있거나 메시지 손실이 없는(최소한의 오류는 표시) 연결을 요구할 뿐이다.

인터넷 상의 일반적인 두 개의 전송프로토콜중 TCP는 신뢰할 수 있으나 UDP는 그렇지 않는다.
그러므로 HTTP연결이 필수는 아니지만 TCP표준에 의존한다.

클라이언트와 서버가 HTTP를 요청/응답으로 교환하기 전에 여러 왕복이 필요한 프로세스인 TCP연결을 설정해야한다.
HTTP/1.0의 기본 동작은 각 요청/응답에 대해 별도의 TCP연결을 여는 것이다. 
이 동작은 여러 요청을 연속해서 보내는 경우 단일 TCP연결을 공유하는 것보다 효율적이지 못하다.

> TCP 연결을 하기 위해서는 서버와 클라이언트 간의 연결을 시도하거나 종료할 때 여러 요청을 주고 받는다.
> 이 과정 속에서 불필요한 오버헤드가 발생한다는 의미인것같다.
> 그러니 잦은 요청보다는 한 번에 연결을 하는게 좋다는 거 같다.
> 
> TCP 연결은 3-way-handshaking 해제는 4-way-handshaking과정을 거친다. 이 내용을 보면 왜 오버헤드가 발생하는지 알 것 같다.

이러한 결험을 개선하기 위해, HTTP/1.1은 (구현하기 어렵다고 입증됨) 파이프 라이닝 개념과 지속적인 연결의 개념을 도입했다.
기본적인 TCP 연결은 Connection헤더를 사용해 부분적으로 제어할 수 있다.
HTTP/2는 연결을 좀 더 지속되고 효율적으로 유지하는데 도움이 되도록,
단일 연결 상에서 메시지를 다중 전송(multiplex)하여 한걸은 더 나아갔다.

HTTP에 더 알맞은 좀 더 나은 전송 프로토콜을 설계하는 실험이 진행 중에 있습니다. 
예를 들어, 구글은 좀 더 신뢰성있고 효율적인 전송 프로토콜을 제공하기 위해 UDP기반의 QUIC를 실험하고 있다.


---

## HTTP로 제어할 수 있는 것

HTTP의 확장 가능한 특성은 수년 간 걸쳐 웹의 더 많은 기능을 제어하도록 허용했다. 
캐시 혹은 인증 메서드는 HTTP에 초기부터 제어해왔던 기능이며,
반면 orgin제약사항을 완화시키는 조치는 2010년에 추가 되었다.


### HTTP 사용하여 제어 가능한 기능 목록

#### 캐시 

- HTTP로 문서가 캐시되는 방식을 제어할 수 있다.
서버는 매시 대상과 기간을 프록시와 클라이언트에 지시할 수 있고 클라이언트는 저장된 문서를 무시하라고 중간 캐시 프록시에게 지시할 수 있다.

> 간단하게 말하면 브라우저에 캐시데이터가 있다면 캐시에서 읽어 네트워크에서 발생하는 Round Trip 시간을 줄인다.

#### origin 제약사항을 완화하기

- 스누핑과 다른 프라이버시 침해를 막기 위해,
브라우저는 웹 사이트 간의 엄격한 분리를 강제한다.
동일한 origin으로부터 온 페이지만이 웹페이지의 전체 정보에 접근할 수 있다. 
그런 제약 사항은 서버에 부담이 되지만, HTTP 헤더를 통해 그것을 완화시킬 수 있다.
그런 덕분에 문서는 다른 도메인으로부터 전달된 정보를 패치워크 할수 있다.

#### 인증

- 어떤 페이지들은 보호되어 오로지 특성 사용자만이 접근할 수도 있다. 
기본 인증은 HTTP를 통해 www-Authenticate 또는 유사한 헤더를 사용해 제공하거나,
HTTP쿠키를 사용해 특정 세션을 설정하여 이루어질 수 있다.

#### 프록시와 터널링

- 서버 혹은 클라이언트 혹은 그 둘 모두는 종종 인트라넷에 위치하며 다른 개체들에게 그들의 실제 주소를 숨기기도 한다.
HTTP 요청은 네트워크 장벽을 가로지르기 위해 프록시를 통해 나가기도 한다.
모든 프록시가 HTTP프록시는 아닌데, 예를 들면 SOCKS 프로토콜은 좀 더 저수준에서 동작한다. 
FTP와 같은 다른 프로토콜도 이 프록시를 통해 처리할 수 있다.

> SOCKS 프로토콜은 서버-클라이언트 간의 TCP나 UDP통신을 프로시 서버를 거쳐 진행하도록 해주는 프로토콜이다.
> 
> 프록시는 일반적으로 HTTP나 SOCKS를 사용해 인터넷에서 통신한다.

#### 세션

- 쿠키 사용은 서버 상태 요청 또는 연결하도록 해준다.
이것은 HTTP가 기본적으로 상태가 없는(Stateless) 프로토콜임에도 세션을 만들어주는 계기가 된다.
이것은 e-커머스 쇼핑 바구니를 위해서 유용할 뿐만 아니라 사용자 구성을 허용하는 모든 사이트에 대해서 유용하다.


---

## HTTP 흐름

클라이언트가 서버와 통신하고자 할 때, 
최종 서버가 됐든 중간 프록시가 됐든 다음 단계의 과정을 수행한다.

1. TCP연결을 연다. TCP연결은 요청을 보내거나(혹은 여러 개의 요청) 응답을 받는데 사용한다.
클라이언트는 새 연결을 열거나, 기존 연결을 재상용하거나, 서버에 대한 여러 TCP 연결을 열 수 있다.
2. HTTP 메시지를 전송한다. HTTP메시지(HTTP/2 이전)는 인간이 읽을 수 있다.
HTTP/2에서는 이런 간단한 메시지가 프레임 속으로 캡슐화 되어 직접 읽는게 불가능 하지만 원칙은 동일하다.

```http request
GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```

3. 서버에 의해 전송된 응답을 읽어들인다.
```http request
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
```

4. 연결을 닫거나 다른 요청들을 위해 재사용한다.

HTTP 파이프라이닝이 활성화되면, 
첫번째 응답을 완전히 수신할 때까지 기다리지 않고 여러 요청을 보낼 수 있다.
HTTP 파이프라이닝은 오래된 소프트웨어와 최신 버전이 공존하고 있는,
기존의 네트워크 상에서 구현하기 어렵다는게 입증되었으며,
프레임 안에서 보다 활발한 다중 요청을 보내는 HTTP/2로 교체되고 있다.

> 마지막에 의미는 잘 모르겠다. 응답을 완전히 수신할 때까지 기다리지 않는다는건 비동기식을 의미하는 건가??
> 
> 동기식 프로그램은 응답이 있은 뒤 다음 작업을 수행하지만 비동기식은 한번에 여러 요청을 하고 여러 응답을 받기 때문이다.. 아니면 어떤걸 의미하는지 확인해 봐야겠다.


---

## HTTP 메시지

HTTP/1.1과 초기 HTTP 메시지는 사람이 읽을 수 있었다.
HTTP/2에서 이 메시지들은 이진 구조인 프레임 안으로 임베드되어, 
헤더의 압축과 다중화와 같은 최적화를 가능하게 한다.


HTTP메시지는 두 가지 타입이 있다. 요청(requests)과 응답(responses)은 각자의 특성있는 가지고 있다.

### 요청

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/086677ec-6b63-496b-8bf5-422ef509065b)

- Method 
  - HTTP 메서드는 보통 클라이언트가 수행하고자 하는 동작을 정의한 ```GET```,```POST```같은 동사나 ```OPTIONS```이나 ```HEAD```와 같은 명사이다.
  - 일반적으로, 클라이언트는 리소스를 가져오거나(```GET```을 사용하여) HTML폼의 데이터를 전송(```POST```를 사용하여)하려고 하지만,
  다른 경우에는 다른 동작이 요구될 수 있습니다.

  > 문서상에서 Form Data는 ```POST```를이 이용해서 전송해야 하는지 잘 모르겠다. 이건 좀 확인을 해봐야겠다.
  > 
  > 일반적으로 From Data는 ```POST```를 이용하는기는 하는데 가능 불가능의 범주는 잘 모르겠다.

- Path
  - 가져오려는 리소스의 경로를 예로들면 프로토콜(http://), 도메인(위 이미지에서 developer.mozilla.org), 또는 TCP 포트(위 이미지에서 80)안 요소들을 제거한 리소스의 URL이다.

- Version of the protocol
  - 서버에 대한 추가 정보를 전달하는 선택적 헤더들.
  - 헤더는 종류가 많으니 확인해봐야한다.


### 응답

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/423dd3be-4542-4de6-8351-0c583a57c459)

- Version of the Protocol: HTTP 프로토콜의 버전
- Status code: 요청의 성공 여부와, 그 이유를 나타내는 상태 코드
- Status message: 아무런 영향력이 없는, 상태 코드의 짧은 설명을 나타내는 상태 메시지
- Headers: 요청 헤더와 비슷한, HTTP 헤더들
- Body: 선택 사항으로 가져온 리소스가 포함되는 본문(이미지 상에는 안보인다.)


---

## HTTP 기반 API

HTTP기반 API중 가장 일반적 사용되는 API는 user agent와 서버간 데이터 교환하는데 사용하는 ```XMLHttpRequest```API이다.

> ```XMLHttpRequest```는 AJAX에서 주로 사용한다.

최신 API인 Fetch API는 보다 강력하고 유연한 기능을 제공한다.

또다른 API인 ```Server-sent event```는 서버 전송 메커니즘으로 HTTP를 사용하여, 
클라이언트로 이벤트를 보낼 수 있도록 하는 단방향 서비스이다.
클라이언트는 ```EventSource```인터페이스를 사용하여, 연결을 맺고 이벤트 핸들러를 설정한다.
클라이언트 브라우저는 HTTP 스트림으로 도착한 메시지를 적절한 Event 객체로 자동 변환하여, 
알려진 경우 해당 이벤트 type에 대해 등록된 이벤트 핸들러로 전달하거나 또는 특정 유형의 이벤트가 설정되지 않은 경우에는 onmessage (en-US) 이벤트 핸들러로 전달합니다.


---

# 결론

HTTP는 사용이 쉬운 확장 가능한 프로토콜이다.
헤더를 쉽게 추가하는 능력을 지닌 클라이언트-서버 구조는 HTTP가 발전할 수 있게 한다.

HTTP/2가 성능 향상을 위해 메시지를 프레임 내로 임베드하여 약간의 복잡함을 더했을지라도,
애플리케이션 관점에서 볼 때, 메시지의 기본적인 구조는 HTTP/1.0이 릴리즈된 이후와 동일하다.

세션의 흐름은 여전히 단순하여, 간단한 HTTP메시지 모니터를 이용해 조사와 디버그도 가능하게한다.


















