# HTTP 개요

### [https://developer.mozilla.org/ko/docs/Web/HTTP/Overview](https://developer.mozilla.org/ko/docs/Web/HTTP/Overview)

**HTTP는 HTML문서와 같은 리소스를 가져울 수 있도록 해주는 프로토콜이다.**
HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초이며, 클라이언트-서버 프로토콜이기도 하다.

클라이언트-서버 프로토콜이란 수신자 측에 의해 요청이 초기화되는 프로토콜을 의미한다.

하나의 완전한 문서(웹 페이지)는 텍스트, 이미지, 비디오 등의 불러온(feched) 하위 문서로 재구성 된다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/d639775b-70bb-4d73-ae9d-839501a3e8f5)

클라이언트와 서버들은 개별적인 메시지 교환에 의해 통신한다(데이터 스트림과 대조적으로). 보통 브라우저인 클라이언트에서 전송하는 메시지 요청(requests)이라고 하며, 그에 대한 서버에서 전송하는 데이터를 메시지 응답(responses)이라고 부른다.

> 문서에서 데이터 스트림과 대조적이란 말이 있는데 데이터 스트림은 연결지향통신이지만 HTTP는 비연결성이라는 특징을 말한 것 같다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/4c9e0df7-7475-4ee3-b87b-05e3b8d645eb)

HTTP는 **애플리케이션 계층의 프로토콜**로, 신뢰 가능한 전송 프로토콜이라면 이론상으로는 무엇이든 사용할 수 있으나 **TCP 혹은 암호화된 TCP 연결인 TLS를 통해 전송**됩니다.

> HTTP/3에서는 TCP,TLS를통하지 않고 QUIC를 사용한다. QUIC는 UDP상에 구현된 프로토콜이다. 이 부분은 좀더 공부해봐야한다.

HTTP의 확장성 덕분에, 오늘날 하이퍼텍스트 문서 뿐만 아니라 이미지 비디오 HTML 폼 결과와 같은 내용을 서버로 포스트(POST)하기 위해서 사용하기도 한다.

---

## HTTP기반 시스템의 구성요소

요청은 하나의 개체, 사용자 에이전트(또는 그것을 대신하는 프록시)에 의해 전송됩니다. 
대부분의 경우, 사용자 에이전트는 브라우저지만, 무엇이든 될 수 있습니다. 
예를 들어, 검색 엔진 인덱스를 채워넣고 유지하기 위해 웹을 돌아다니는 로봇이 그러한 경우입니다.

> 마지막 문장의 로봇은 검색엔진에서 웹크롤링을 하기 위한 로봇으로 생각된다.

개별적인 요청들은 서버로 보내지며, 서버는 요청을 처리하고 response라고 불리는 응답을 제공한다.
이 요청과 응답 사이에는 어러 개체들이 있다.
예를 들면 다양한 작업을 수행하는 게이트웨이 또는 캐시 역할을 하는 프록시 등이 있다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/5b46ca36-8a51-4d6f-9a2e-d38a7be04c13)

실제로는 브라우저와 서버사이에는 좀 더 많은 컴퓨터들이 존제한다.: 라우터, 모뎀 등

웨의 계층적 설계 덕분에, 이들은 네트워크와 전성 계층내로 숨겨지고 HTTP는 애플리케이션 계층에 있다. 
네트워크 문제를 진단하는 것도 중요하지만, 기본 레이어들은 HTTP 명세와는 거의 관련이 없다.

--- 

## 클라이언트: 사용자 에이전트

**사용자 에이전트는 사용자를 대신하여 동작하는 모든 도구이다.**

이 역할은 주로 브라우저에 의해 수행되며, 엔지니어들과 자신들의 애플리케이션을 디버그하는 웹 개발자들이 사용하는 프로그램은 예외이다.

> 디버그하는 웹 개발자들이 사용하는 프로그램이라는건 PostMan같은걸 의미하나보다.

브라우저는 **항상** 요청을 보내는 개체이다. 브라우저는 결코 서버가 될 수 없다.

웹페이지를 표시하기 위해, 브라우저는 페이지의 HTML문서를 가져오기 위한 요청을 전송한 뒤, 
파일을 구문 분석하여 실행해야 할 스크립트 그리고 페이지 내 포함된 하위 리소스들(이미지나 비디오 등)을 잘 표시하기 위한 레이아웃 정보(CSS)에 대응하는 추가적인 요청들을 가져온다.
그런 뒤에 브라우저는 완전한 문서인 웹 페이지를 표시하기 위해 받아온 리소스들을 혼합하고 그에 따라 웹페이지를 갱신하게 된다.

---

## 웹 서버

클라이언트에 의한 요청에 대한 문서를 제공하는 서버가 존재한다.
서버는 사실 상 논리적으로 단일 기계이다. 이는 로드벨런싱 혹은 그때 그때 다른 컴퓨터(캐시, DB 서버 등과 같은)들의 정보를 얻고 완전하게 혹은 부분적으로 문서를 생성하는 소프트웨어의 복잡한 부분을 공유하는 서버들의 집합 일 수 있기 때문이다.

서버는 반드시 단일 머신일 필요는 없지만, 여러 개의 서버를 동일한 머신 위에서 호스팅 할 수는 있다.

---

## 프록시

웹 브라우저와 서버 사이에서는 수많은 컴퓨터와 머신이 HTTP 메시지를 이어 받고 전달한다.
여러 계층으로 이루어진 웹 스택 구조에서는 이러한 컴퓨터/머신들은 대부분 전송, 네트워크 혹은 물리계층에서 동작하며,
성능에 상당히 큰 영향을 주지만 HTTP계층에서는 이들이 어떻게 동작하는지 눈에 보이지 않는다.
이러한 컴퓨터/머신 중에서도 애플리케이션 계층에서 동작하는 것들을 일반적으로 **프록시**라고 부른다
프록시는 눈에 보이거나 그렇지 않을 수도 있으며(프록시를 통해 요청이 변경되거나 변경되지 않는 경우를 말함) 다양한 기능들을 수행할 수 있다.

- 캐싱: 캐시는 공개 또는 비공개가 될 수 있다.(예: 브라우저 캐시)
- 필터링: 바이러스 백신 스캔, 유해 컨텐츠 차단 기능
- 로드 밸런싱: 여러 서버들이 서로 다른 요청을 처리하도록 허용
- 인증: 다양한 리소스에 대한 접근 제어
- 로깅: 이력 정보 저장

---

## HTTP의 기초적인 측면

### HTTP는 간단합니다.

HTTP는 사람이 읽을 수 있으며, 간단하게 고안되었다. 
심지어 HTTP/2가 다서 더 복자해졌지만 여전히 HTTP 메시지를 프레임별로 캡슐화하여 간결함을 유지하였다.
HTTP 메시지들은 사람이 읽고 이해할 수 있어, 테스트가 쉽고 초심자의 진입장볍을 낮췄다.

### HTTP는 확장 가능하다.

HTTP/1.0에서 소개된, HTTP 헤더는 HTTP를 확장하고 실험이 쉽게 만들어졌다.
클라이언트와 서버가 새로운 헤더의 시맨틱에 대해 간단한 합의만 한다면, 
언제든지 새로운 기능을 추가할 수 있습니다.

### HTTP는 상태는 없지만 세션은 있다.

HTTP는 상태를 저장하지 않는다(Stateless).
동일한 연결 상에서 연속하여 전달된 두 개의 요청은 아무 연결 고리가 없다.
이는 쇼핑 장바구니처럼 **일관된 방식으로 사용자가 페이지와의 상호작용을 원할 때 문제가된다.**
하지만 HTTP의 쿠키는 상태가 있는 세션을 만들도록 해준다. 
헤더 확장성을 사용하여, 동일한 컨텍스트 또는 동일한 상태를 공유하기 위해 각각의 요청들에 세션을 만들도록 HTTP 쿠키가 추가된다.

> 일관된 방식으로 사용자가 페이지와의 사용작용을 원할 때 문제가 된다고 했는데,
> 
> 예를들어 상태를 저장하지 않는다면, 
> 장바구니에 담은 품목이 다른 페이지로 넘어가면서 상태저장이 안되고 장바구니에 넣은 품목들이 사라진다는 것이다.
> 하지만 쿠키를 이용해 브라우저와 서버와 세션을 만들게 된다면,
> 우리가 사용하는 장바구니처럼 다른 페이지로 넘어가도 장바구니에 추가한 상품이 없어지지 않는다.


---

HTTP와 연결

연결은 전송 계층에서 제어되므로 HTTP의 영역 밖이다.(HTTP는 위에서도 나왔듯이 애플리케이션 계층이다.)
HTTP는 연결될 수 있도록 하는 근본적인 전송 프로토콜을 요구하지 않는다.
다만 그저 신뢰할 수 있거나 메시지 손실이 없는(최소한의 오류는 표시) 연결을 요구할 뿐이다.

인터넷 상의 일반적인 두 개의 전송프로토콜중 TCP는 신뢰할 수 있으나 UDP는 그렇지 않는다.
그러므로 HTTP연결이 필수는 아니지만 TCP표준에 의존한다.

클라이언트와 서버가 HTTP를 요청/응답으로 교환하기 전에 여러 왕복이 필요한 프로세스인 TCP연결을 설정해야한다.
HTTP/1.0의 기본 동작은 각 요청/응답에 대해 별도의 TCP연결을 여는 것이다. 
이 동작은 여러 요청을 연속해서 보내는 경우 단일 TCP연결을 공유하는 것보다 효율적이지 못하다.

> TCP 연결을 하기 위해서는 서버와 클라이언트 간의 연결을 시도하거나 종료할 때 여러 요청을 주고 받는다.
> 이 과정 속에서 불필요한 오버헤드가 발생한다는 의미인것같다.
> 그러니 잦은 요청보다는 한 번에 연결을 하는게 좋다는 거 같다.
> 
> TCP 연결은 3-way-handshaking 해제는 4-way-handshaking과정을 거친다. 이 내용을 보면 왜 오버헤드가 발생하는지 알 것 같다.

이러한 결험을 개선하기 위해, HTTP/1.1은 (구현하기 어렵다고 입증됨) 파이프 라이닝 개념과 지속적인 연결의 개념을 도입했다.
기본적인 TCP 연결은 Connection헤더를 사용해 부분적으로 제어할 수 있다.
HTTP/2는 연결을 좀 더 지속되고 효율적으로 유지하는데 도움이 되도록,
단일 연결 상에서 메시지를 다중 전송(multiplex)하여 한걸은 더 나아갔다.

HTTP에 더 알맞은 좀 더 나은 전송 프로토콜을 설계하는 실험이 진행 중에 있습니다. 
예를 들어, 구글은 좀 더 신뢰성있고 효율적인 전송 프로토콜을 제공하기 위해 UDP기반의 QUIC를 실험하고 있다.


---












