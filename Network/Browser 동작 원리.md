# 브라우저의 동작 원리

## 개요

빠른 사이트는 더 좋은 사용자 경험을 제공하며,
사용자는 로드가 빠르고 상호작용이 원활한 웹 경험을 원한다.

웹 성능에 있어 두 가지 주요한 문제는 지연시간과 브라우저가 대부분 싱글 쓰레드로 동작한다는 점이다.

> Java Script가 싱글 쓰레드이기 때문에 이런 내용이 있는것 같다.

빠른 로딩을 하는데 있어서 지연시간은 중요한 문제이다.
빠른 로딩을 위해 신경써야할 것에는 빠르게 데이터를 요청하는것도 포함된다.
네트워크 지연시간은 네트워크를 통해 컴퓨터로 바이트를 전송하는데 걸리는 시간을 의미하며,
웹 최적화는 페이지 로드가 최대한 빠르게 이루어질 수 있도록 하는 것이다.

대부분의 브라우저는 싱글 쓰레드이다.
원활한 상호작용을 위한 개발자의 목표는 부드러운 스크롤부터 터치에 이르기까지 성능이 뛰어난 상호 작용을 보장하는 것이다.
메인 쓰레드가 요청된 모든 작업을 수행하면서도 유저와의 상호작용에 반응 할 수 있도록 보장하기 위해서는 렌더링 시간이 가장 중요하다.
브라우저가 싱글 쓰레드로 동작한다는 점을 이해하고 가능한 메인 쓰레드의 책임을 줄여주는 방식으로 웹 성능 향상을 이룰 수 있다.
이렇게 한다면 렌더링은 부드럽고 상호작용에 대한 응답은 즉각적일 것이다.


## 1. 탐색(Navigation)

탐색(Navigation)은 웹페이지를 로딩하는 첫 단계이다. 사용자가 주소창에 URL을 입력하거나,
링크를 클릭하고, 폼(form)을 제출하는 등의 동작을 통해 요청을 보낼 때마다 발생한다.

웹 최적화의 목표 중 하나는 탐색이 완료될 때까지의 시간을 최소화 하는 것이다.
이상적인 조건에서 그다지 오래 걸리는 작업이 아니지만 지연시간과 대역폭은 지연을 일으키는 적이다.

### 1.1. DNS 조회(DNS Lookup)

웹 페이지를 탐색하는 첫 단계는 해당 페이지의 자원이 어디에 위치한지 확인하는 것이다.
만약 ```https://example.com```을 접속하길 원한다.
```https://example.com```의 HTML페이지는 IP주소가 ```93.184.216.34```서버에 위치하고,
만약 이 사이트를 한 번도 방문한 적이 없다면 DNS 조회가 필요하다.

브라우저는 DNS 조회를 요청한다.
이는 최종적으로 DNS에 의해 처리되고, IP주소로 응답한다.
최초의 요청 이후에, IP는 일정 기간 동안 캐시되고,
DNS에 다시 연락하는 대신 캐시에서 IP주소를 검색해 후속 요청 속도를 높힌다.

DNS 조회는 보통 호스트 이름 하나당 한 번만 수행된다. 
하지만 요청된 페이지에서 참조하는 자원들이 서로 다른 호스트 이름을 가지고 있다면 DNS 조회를 각각 수행해야 한다.
예를들어 글꼴, 이미지, 스크립트, 광고 등 다른 자원들이 서로 다른 호스트 이름을 가지고 있다면,
각 자원에 따라 DNS조회가 필요하다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/a1f21973-e444-43b5-b078-12ae5da1a3e3)

이는 모바일 네트워크 환경에서 문제가 될 수 있다. 
사용자가 모바일 환경에 있을 때, 각각의 DNS조회는 휴대폰에서 셀타워에 가야하고, 
셀타워에서 권위있는 DNS 서버에 도달해야한다.
휴대폰과 셀 타워, 그리고 DNS 거리에 따라서 상당한 지연이 발생할 수 있다.

> 위 휴대폰에 관한 예시는 대한민국에서 맞지 않을지도 모르겠다. 

### 1.2. TCP 핸드 세이크(TCP Handshake)

IP주소를 알고 난 후에, 브라우저는 서버와 TCP 3-way-handshake을 통해 연결을 설정한다.
이 방식은 데이터를 전송하기 전에 통신하려는 두 주체가 TCP소켓 연결을 위한 매개변수를 주고 받을 수 있도록 만들어졌다.

> TCP를 이용해 연결을 할땐 3 way handshake,
> 연결을 헤지하는 과정은 4 way handshake 과정으로 진행된다.

TCP의 3way hand shake 기술은 "SYN-SYN-ACK"로 불리기도 한다.
두 컴퓨터 간 TCP 세션을 협상하고 시작하기 위해 TCP가 3개의 메시지를 전달하기 때문이다.
이는 요청이 보내지기 전 3개의 추가 메시지가 컴퓨터 사이에 주고 받아진다는 의미이기도 하다.

### 1.3. TLS 협상(TLS Negotiation)

HTTPS를 이용한 보안성있는 연결을 위해서 또 다른 "핸드세이크가" 필요하다.
이 핸드세이크는 통신 암호화에 쓰일 암호를 결정하고, 서버 확인과 실제 데이터 전송 전에 안전한 연결이 이루어지도록 한다.
이를 위해서 자원에 대한 실제 요청 전에 클라이언트에서 서버로 3번 더 왕복해야한다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/ad1c5d71-acc3-4dbb-8f4c-2dba8aad6c09)

연결에 보안성을 더하는 것은 페이지 로딩을 더디게 하지만 보안성은 지연시간이라는 비용을 낼만큼 충분히 가치가 있다.
브라우저와 웹서버 사이에 전송되는 데이터가 제 3자에 의해 해독될 수 없게 되기 때문이다.

> 8번의 왕복이 있은 후, 브라우저는 마침내 요청을 할 수 있다.


---

## 2. 응답(Response)

웹 서버로 한 번 연결이 성립되고 나면, 브라우저는 유저 대신에 초기 HTTP request를 보낸다.
웹사이트는 대게 HTML 파일을 요청하고,
서버가 요청을 받으면, 관련 응답 헤더와 함께 HTML의 내용을 응답하게 된다.

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>My simple page</title>
    <link rel="stylesheet" src="styles.css" />
    <script src="myscript.js"></script>
  </head>
  <body>
    <h1 class="heading">My Page</h1>
    <p>A paragraph with a <a href="https://example.com/about">link</a></p>
    <div>
      <img src="myimage.jpg" alt="image description" />
    </div>
    <script src="anotherscript.js"></script>
  </body>
</html>
```

초기 요청에 대한 응답은 수신된 첫 바이트 데이터를 포함하고 있다.
Time to First Byte(TTFB)는 사용자가 요청을 보내고 HTML의 첫 패킷을 받는데 걸린 시간이다.

첫 번째 컨텐츠 청크는 일반적으로 14KB크기의 데이터이다.

위 예제에서, 요청은 14KB보다 작다. 하지만 아래에서 설명하는 것처럼 구문 분석되는 중에 브라우저가 링크를 만날 때까지 링크가 걸린 자원들은 요청되지 않는다.

### 2.1. TCP 슬로우 스타트(TCP Slow Start) / 14kb rule

첫 응답 패킷은 14kb이다. 
이는 네트워크 통신의 속도를 조절하는 알고리즘인 TCP 슬로우 스타트에 의해 정해진 것이다.
슬로우 스타트는 네트워크의 최대 대역폭을 파악할 수 있을 때까지 점진적으로 데이터의 전송량을 증가시킨다.

TCP슬로우 스타트 방식에 따라, 첫 패킷을 받고난 이후에 서버는 다음 패킷의 사이즈를 두 배인 28kb로 늘린다.
뒤 이은 패킷의 크기도 미리 정의한 임계치에 다다르거나, 혼잡의 징후가 나타나기 전까지 2배씩 커진다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/020a8003-4bfd-44dd-b7ec-48902ecfccb8)

첫 페이지 로딩에 관련해 14kb 법칙이 있는데, 
TCP의 슬로우 스타트가 초기 응답의 크기가 14kb인 이유이다.
그리고 웹 최적화를 할 때 초기 14kb 응답을 염두해두어야 하는 것도 이 때문이다.
TCP 슬로우 스타트는 혼잡을 피하기 위해 네트워크의 용량에 적당한 전송 속도를 찾고자 점진적으로 속도를 높여간다.

### 2.2. 혼잡 제어(Congestion control)

서버가 TCP 패킷으로 데이터를 보내면서, 
사용자의 클라이언트는 확인응답(Acknowledgements, ACKs)을 보내면서 데이터의 수신을 확인해준다.
연결은 하드웨어나 네트워크 상태에 따라 제한된 용량만을 가지고 있으며,
만약 서버가 패킷을 너무 빠르게 모내게 되면, 그 패킷들은 무시가 될 것이다.
즉, 확인 응답이 없을 것이다.
서버는 이를 누락된 확인 응답으로 파악하고, 혼잡 제어 알고리즘은 보내진 패킷의 흐름과 확인 응답을 바탕으로 전송 속도를 결정한다.

---

## 3. 구문 분석(Parsing)

브라우저가 첫 번째 데이터의 청크를 받으면, 수신된 정보를 구문 분석한다.
구문 분석은 브라우저가 네트워크를 통해 받은 데이터를 DOM이나 CSSOM으로 바꾸는 단계이다.
이는 렌더러가 화면에 페이지를 그리는데 사용한다.

브라우저는 마크업을 내부적으로 DOM으로 표현한다. 
DOM은 공개되어있고 Javascript의 다양한 API를 통해 조작할 수 있다.

요청된 HTML 페이지의 크기가 초기 패킷의 크기인 14kb보다 크더라도, 
브라우저는 구문 분석을 시작하고 가지고 있는 데이터 수준에서 렌더링을 시도한다.
이것이 웹 성능 최적화에서 브라우저가 페이지를 렌더링 하는데 필요한 모든 것, 
아니면 적어도 페이지의 템플릿(첫 렌더링에 필요한 HTML, CSS)만이라도 첫 14kb에 포함해야하는 이유이다.
하지만 화면에 렌더링하기전에 HTML, CSS, Javascript를 구문 분석해야 한다.

> 첫 요청에 렌더링할 데이터를 보내줘야 사용자 입장에서 빠르게 화면이 렌더링 되는것처럼 느끼는 것인가??

### 3.1. DOM 트리 구축(Building the DOM tree)

HTML을 처리하여 DOM트리를 만든다. 
HTML 구문 분석은 토큰화와 트리 생성을 포함한다.
HTML 토큰은 시작 및 종료 태그 그리고 속성 이름 및 값을 포함한다.
만약 문서가 잘 구성되어 있다면 구문 분석은 명확하고 빠르게 이루어진다.
구문 분석기는 토큰화된 입력을 분석하여 DOM트리로 만든다.

DOM트리는 문서의 내용을 설명한다. 
```<html>```는 시작하는 태그이고 DOM트리의 루트 노드이다.
트리는 다른 태그간의 관계와 계층을 반영한다.
다른 태그에 감싸져 있는 태그는 자식 노드이며, 
DOM노드의 개수가 많아질수록, 
DOM트리를 만드는데 오랜 시간이 걸리게 된다.

![image](https://github.com/YoonSeok-Heo/TIL/assets/113662725/d5906f1d-01d9-490a-a556-d338d6766e99)

구문 분석기가 이미지와 같은 논 블로킹 자원을 발견하면,
브라우저는 해당 자원을 요청하고 분석을 계속한다.
구문 분석은 CSS파일을 만났을 때도 지속될 수 있다.
하지만 ```async```나 ```defer```같은 설정이 되어있지 않은 ```<script>```태그는 렌더링을 막고,
HTML의 분석을 중지시킨다.
브라우저의 프리로드 스캐너가 이 작업을 가속화하지만, 과도한 스크립트는 여전히 주요한 병목구간이 된다.

### 3.2. 프리로드 스캐너(Preload scanner)

브라우저가 DOM 트리를 만드는 프로세스는 메인 쓰레드를 차지한다.

> 메인 쓰레드가 있다는 건 다른 쓰레드 또한 있다는 건가??? 싱글 쓰레드라며...??

그렇기 때문에, 프리로드 스캐너는 사용가능한 컨텐츠를 분석하고 
CSS, Javascript, 웹 폰트 같이 우선순위가 높은 자원을 요청한다.
프리로드 스캐너 덕에 구문 분석기가 외부 자원에 대한 참조를 찾아 요청하기까지 기다리지도 않아도 되며,
프리로드 스캐너가 자원을 뒤에서 미리 요청한다.
그래서 구문 분석기가 요청되는 자원에 다다를 때 쯤이면 이미 그자원들은 전송받고 있거나 이미 전송받은 후일 것입니다.
프리로드 스캐너가 제공하는 최적화는 블록킹을 줄여준다.

```html
<link rel="stylesheet" src="styles.css" />
<script src="myscript.js" async></script>
<img src="myimage.jpg" alt="image description" />
<script src="anotherscript.js" async></script>
```

위 예제에서 메인 쓰레드가 HTML과 CSS를 분석하고 있을 때, 
프리로드 스캐너는 스크립트와 이미지를 찾아 다운로드하기 시작할 것이다. 
Javascript의 분석과 실행 순서가 중요하지 않고 스크립트가 프로세스를 막지 않도록 하려면 ```async``` 속성이나 ```defer```속성을 추가해야한다.

CSS를 다운로드하는 것은 HTML분석이나 다운로드를 막지 않습니다.
하지만 JavaScript실행은 막는다.
Javascript는 종종 요소에 영향을 주는 CSS속성들을 조작하기 때문이다.

---

### 3.3. CSSOM 구축 (Building the CSSOM)

중요한 렌더링 경로에서 두 번째 단계는 CSS를 처리하고 CSSOM트리를 만드는 것이다.
CSS객체 모델은 DOM과 비슷하며, DOM과 CSSOM은 둘 다 트리구조이다.
둘은 각각의 독립적인 자료구조이며, 브라우저는 CSS규칙을 이해할 수 있고 작업을 진행할 수 있도록 스타일 맵으로 변환한다.
브라우저는 CSS에 있는 각각의 규칙을 읽고, 트리 노드를 만든다.
CSS 선택기에 기반해서 부모 노드, 자식노드, 형제 관계의 노드가 만들어진다.

HTML이 그러한 것처럼, 브라우저는 전송받은 CSS규칙을 작업 가능한 상태로 변환해야 합니다.
따라서 브라우저는 HTML을 객체로 바꾼 프로세스를 CSS에 대해서 다시 한번 합니다.

CSSOM트리는 사용자 에이전트의 스타일 시트를 포함한다.
브라우저는 노드에 적용 가능한 가장 일반적인 규칙부터 적용하고,
재귀적으로 더 구체적으로 적용된 규칙에 따라 계산된 스타일을 수정해간다.
다른 말로, 속성 값을 캐스케이드(Cascade) 한다.

> Cascade가 종속된다고 보면 되는건가??

CSSOM을 만드는데 드는 시간은 일반적으로 한 번의 DNS조회를 하는 시간보다 짧기 때문에 웹 성능 최적화 관점에서 CSSOM은 성능 향상에 큰 기여를 하는 영역은 아니다.





































